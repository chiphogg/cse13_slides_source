---
title       : Showing surface uncertainty using smooth animations
subtitle    : 
author      : Charles R. Hogg III
job         : 
framework   : io2012        # {io2012, html5slides, shower, dzslides, ...}
highlighter : highlight.js  # {highlight.js, prettify, highlight}
hitheme     : tomorrow      # 
widgets     : [mathjax, bootstrap]     # {mathjax, quiz, bootstrap}
mode        : selfcontained # {standalone, draft}

```{r setup, include=FALSE}
require(knitr)
require(gppois)
require(ggplot2)
opts_chunk$set(fig.width=13, fig.height=5, warning=FALSE, cache=TRUE,
  dev='CairoPNG', echo=FALSE)
theme_set(theme_classic(40))
knit_hooks$set(webgl = function(before, options, envir) {
  library(rgl)
  ## after a chunk has been evaluated
  if (before || rgl.cur() == 0) return()  # no active device
  name <- sprintf('rgl_%s.html', options$label)
  par3d(windowRect = 100 + options$dpi * c(0, 0, options$fig.width, options$fig.height))
  Sys.sleep(.05) # need time to respond to window size change
  writeLines(c('%WebGL%', '<script>webGLStart();</script>'), tpl <- tempfile())
  writeWebGL(dir = dirname(name), filename = name, template = tpl)
  sprintf('<iframe src="%s" width="%s" height="%s"></iframe>', name,
    options$dpi * options$fig.width, options$dpi * options$fig.height)
})
```

---

## Motivation

### Level 3 heading

Easy to make **bold** or _italic_.

Also easy to $E = mc^2$

Or, $p(x | \theta) = \frac{1}{\sqrt{2\pi \sigma^2}} \exp \left[ -\frac{1}{2} \frac{(x - \theta)^2}{\sigma^2} \right]$

Why _animations?_

---

### Sequence of slides go here

---

## Decoupling the Problem

We can _reduce_ our problem to a **single random variable**.

(Visualization: smooth series of points in top left, covariance in top right, lower cholesky in bot right, noisy sequence in bot left)

---

## Caveat: statistics

  <div style='font-size: 2em; text-align: center;'>
    Too easy to mislead...
  </div>

---

## Caveat: statistics (individual points)

```{r}
set.seed(1)
N.frames <- 14
t.frames <- 1:N.frames
Y.data <- rnorm(length(t.frames))
single.points <- geom_point(size=4)
p.base <- (ggplot(data=data.frame(x=t.frames, y=Y.data), aes(x=x, y=y))
  + scale_x_continuous("Time")
  + scale_y_continuous("", limits=3 * c(-1, 1))
  )
print(p.base + single.points)
```

---

## Caveat: statistics (naive interpolation)

```{r}
print(p.base
  + single.points
  + geom_line()
  )
```

---

## Caveat: statistics (entire distribution)

```{r}
pts.per.frame <- 200
new.data <- data.frame(x=t.frames, y=rnorm(pts.per.frame * N.frames),
  label=rep(paste('a', 1:pts.per.frame, sep=''), each=N.frames))
dist.points <- geom_point(data=new.data, colour='grey')
print(p.base
  + dist.points
  + single.points
  + geom_line()
  )
```

---

## Caveat: statistics (interpolated distribution)

```{r}
dist.lines <- geom_line(data=new.data, aes(group=label), colour='grey')
print(p.base
  + dist.points
  + dist.lines
  + single.points
  + geom_line()
  )
```

<div style='font-size: 1.6em; text-align: center;'>
  Statistics <em>between</em> keyframes<br>
  are <strong>clearly different</strong><br>
  from statistics <em>at</em> keyframes
</div>

---

## Solution: connect differently

```{r}
print(p.base
  + single.points
  + geom_line()
  )
```

---

## Solution: connect differently

```{r}
N.out <- 500
t.out <- seq(from=head(t.frames, 1), to=tail(t.frames, 1), length=N.out)
weight <- function(t.in, t.out) {
  ifelse(abs(t.in - t.out) > 1, 0, cos((t.in - t.out) * pi / 2))
}
mat.interpolate <- outer(t.out, t.frames, weight)
esg.data <- data.frame(x=t.out, y=mat.interpolate %*% Y.data)
esg.lines <- geom_line(data=esg.data, aes(x=x, y=y))
print(p.base
  + single.points
  + esg.lines
  )
```

---

## Distributions: old connection

```{r}
dist.lines <- geom_line(data=new.data, aes(group=label), colour='grey')
print(p.base
  + dist.points
  + dist.lines
  + single.points
  + geom_line()
  )
```

---

## Distributions: new connection

```{r}
temp.matrix <- matrix(new.data$y, ncol=pts.per.frame)
interp <- mat.interpolate %*% temp.matrix
new.data.lines <- data.frame(x=t.out, y=as.vector(interp),
  label=rep(paste('a', 1:pts.per.frame, sep=''), each=N.out))
esg.dist.lines <- geom_line(data=new.data.lines, colour='grey',
  aes(x=x, y=y, group=label))
print(p.base
  + esg.dist.lines
  + single.points
  + esg.lines
  )
```
**E**hlschlaeger, **S**hortridge, **G**oodchild (**ESG**)
> - By eye: looks like better statistics
> - By math: easy to prove **same distribution at all times**

---

## ESG: Basis function view

```{r}
esg.basis.plot <- function(n) {
  d <- data.frame(t=t.out, y=as.vector(mat.interpolate[, 1:n]),
    label=rep(paste('a', 1:n, sep=''), each=N.out))
  p <- (ggplot(data=d, aes(x=t, y=y, colour=label))
    + geom_line(size=1.5)
    + scale_x_continuous('Time', limits=c(1, n))
    + scale_colour_brewer(palette='Set1')
    + theme(legend.position='none')
    )
  return (p)
}
p.esg.6 <- esg.basis.plot(6)
rect <- data.frame(x1=1, x2=2, y1=-Inf, y2=Inf)
print (p.esg.6)
```

<div style='text-align: center; margin-top: -2em;'>
$$y(t) = \sum_{i=1}^N \epsilon_i b_i(t) \;\;\;\;\;\;
\epsilon_i \underset{\text{i.i.d.}}{\sim} N(0, \sigma^2) $$
</div>

> - **NOTE**: $y(t)$ is sum of Gaussian random variables $\rightarrow$ _is also Gaussian_
> - $\therefore$ statistics completely determined by mean and variance, or
    $\langle y(t) \rangle$ and $\langle y(t)^2 \rangle$

---

## ESG: Checking the statistics

```{r}
print (p.esg.6
  + geom_rect(inherit.aes=FALSE, data=rect, aes(xmin=x1, xmax=x2, ymin=y1, ymax=y2), colour='black', alpha=0.4)
  )
```

<div style='text-align: center;'>
Zoom in on a single transition region...
</div>

---

## Statistics in the transition region

```{r include=FALSE, cache=FALSE}
p <- (esg.basis.plot(2)
  + scale_y_continuous(breaks=c(0, 0.5, 1))
  + scale_x_continuous('Time', breaks=c(1, 1.5, 2), limits=c(1, 2),
    labels=(c(expression(t[1]), '', expression(t[2]))))
  )
```

```{r fig.height=4, cache=FALSE}
print (p)
```

  <ul class='block2 build' style='margin-top: -1em;'>
    <li style='width: 40%;'>
      $$\begin{split}
      \langle y(t) \rangle &= \langle \epsilon_1 \rangle b_1(t) + \langle \epsilon_2 \rangle b_2(t) \\
      &= 0
      \end{split}$$
    </li>
    <li style='width: 60%;'>
      $$\begin{split}
      \langle y(t)^2 \rangle &= b_1(t)^2 \langle \epsilon_1^2 \rangle + 2b_1(t)b_2(t)\langle \epsilon_1\epsilon_2 \rangle + b_2(t)^2 \langle \epsilon_2^2 \rangle \\
      &= \sigma^2 (b_1(t)^2 + b_2(t)^2)
      \end{split}$$
    </li>
    <li style='font-size: 1.4em; width: 100%; margin-top: -1.2em;'>
      $\therefore$ want $(b_1(t)^2 + b_2(t)^2) \equiv 1 \;\;\; \forall t$
    </li>
    <li style='font-size: 1.4em; width: 100%;'>
      $b_1(t) = \cos\left(\frac{t-t_1}{t_2-t_1}\frac{\pi}{2}\right) \;\;\;\;\;\;\;\; b_2(t) = \sin\left(\frac{t-t_1}{t_2-t_1}\frac{\pi}{2}\right)$
    </li>
  </ul>

---

## Old stuff

### Existing Solution

ESG 1997.
  - Pro:
    - Elegant, obviously-correct interpolation
    - Computationally fast
  - Con:
    - Chained to keyframes
      - Abrupt velocity changes

Good segueway into the advantages of mine...

Advantages of ESG which mine retains:
  - Simple, elegant, exact
Disadvantages of ESG which mine corrects:
  - perfectly smooth motion
  - no longer chained to keyframes!

_One line of `R` code!_\
...with `n` semicolons\
(Okay, it's `n+1` lines of `R` code.)

---

# Other ideas

Atomic motion might be a good way to show the advantages of smoothness

---

## Conclusions

- Part of my goal is to make ESG's excellent work more widely known
- Animated uncertainty visualization belongs in the toolbox of every statistical researcher.
- If that uncertainty has a Gaussian distribution, the method I've presented is an excellent way to achieve it.
